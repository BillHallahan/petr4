Title : Petr4 Semantics
Title Note: version 0.0.1
Title Footer: &date;
Author: The Petr4 Team
Heading depth: 5
Pdf Latex: xelatex
Document Class: [11pt]article
Package: [top=1in, bottom=1.25in, left=1in, right=1in]geometry
Package: fancyhdr
Package: mathpartir
Package: textcomp

.mathpre {
  replace: "/( +)\|-( +)/\1\vdash{}\2/g";
  replace: "/-\>/\to{}/g";
  replace: "/\bG\b/\Gamma{}/g";
  replace: "/\bD\b/\Delta{}/g";
  replace: "/\bt\b/\tau{}/g";
  replace: "/\bint<([^>]+)>/\texttt{int}\langle{}\1\rangle{}/g";
  replace: "/\bbit<([^>]+)>/\texttt{bit}\langle{}\1\rangle{}/g";
  replace: "/\bint\b/\texttt{int}/g";
  replace: "/\bbool\b/\texttt{bool}/g";
  replace: "/\btrue\b/\texttt{true}/g";
  replace: "/\bfalse\b/\texttt{false}/g";
  replace: "/\bstring\b/\texttt{string}/g";
}

Infer {
  replace:"/(\n|^)\n *----+ *\[([^\]]*)\] *\n([\s\S]*)/\
           \\infer{{}}{\3}{\textsc{\2}}/m";
  replace:"/([\s\S]*?)\n *----+ *\[([^\]]*)\] *\n([\s\S]*)/\
           \\infer{\1}{\3}{\textsc{\2}}/m";
  replace:"~ Begin MathPre {.infer}&nl;&nl;&source;&nl;\
           ~ End MathPre";
}

Tex Header:
  \setlength{\headheight}{30pt}
  \renewcommand{\footrulewidth}{0.5pt}

@if html {
body.madoko {
  font-family: utopia-std, serif;
}
title,titlenote,titlefooter,authors,h1,h2,h3,h4,h5 {
  font-family: helvetica, sans-serif;
  font-weight: bold;
}
pre, code {
  language: p4;
  font-family: monospace;
  font-size: 10pt;
}
}

@if tex {
body.madoko {
  font-family: UtopiaStd-Regular;
}
title,titlenote,titlefooter,authors {
  font-family: sans-serif;
  font-weight: bold;
}
pre, code {
  language: p4;
  font-family: LuxiMono;
  font-size: 75%;
}
}

Colorizer: p4
.token.keyword    {
    font-weight: bold;
}

@if html {
p4example {
  replace: "~ Begin P4ExampleBlock&nl;\
                 ````&nl;&source;&nl;````&nl;\
                 ~ End P4ExampleBlock";
  padding:6pt;
  margin-top: 6pt;
  margin-bottom: 6pt;
  border: solid;
  background-color: #ffffdd;
  border-width: 0.5pt;
}
}

@if tex {
p4example {
  replace: "~ Begin P4ExampleBlock&nl;\
                 ````&nl;&source;&nl;````&nl;\
                 ~ End P4ExampleBlock";
  breakable: true;
  padding: 6pt;
  margin-top: 6pt;
  margin-bottom: 6pt;
  border: solid;
  background-color: #ffffdd;
  border-width: 0.5pt;
}
}


@if html {
p4pseudo {
  replace: "~ Begin P4PseudoBlock&nl;\
                 ````&nl;&source;&nl;````&nl;\
                 ~ End P4PseudoBlock";
  padding: 6pt;
  margin-top: 6pt;
  margin-bottom: 6pt;
  border: solid;
  background-color: #e9fce9;
  border-width: 0.5pt;
}
}

@if tex {
p4pseudo {
  replace: "~ Begin P4PseudoBlock&nl;\
                 ````&nl;&source;&nl;````&nl;\
                 ~ End P4PseudoBlock";
  breakable : true;
  padding: 6pt;
  margin-top: 6pt;
  margin-bottom: 6pt;
  background-color: #e9fce9;
  border: solid;
  border-width: 0.5pt;
}
}

@if html {
p4grammar {
  replace: "~ Begin P4GrammarBlock&nl;\
                 ````&nl;&source;&nl;````&nl;\
                 ~ End P4GrammarBlock";
  border: solid;
  margin-top: 6pt;
  margin-bottom: 6pt;
  padding: 6pt;
  background-color: #e6ffff;
  border-width: 0.5pt;
}
}

@if tex {
p4grammar {
  replace: "~ Begin P4GrammarBlock&nl;\
                 ````&nl;&source;&nl;````&nl;\
                 ~ End P4GrammarBlock";
  breakable: true;
  margin-top: 6pt;
  margin-bottom: 6pt;
  padding: 6pt;
  background-color: #e6ffff;
  border: solid;
  border-width: 0.5pt;
}
}

[TITLE]

~ Begin Abstract
The goal of the Petr4 project is to define a formal semantics for the
P4 Programming Language.
~ End Abstract

[TOC]

# Introduction { #sec-introduction }
# Syntax { #sec-syntax }

## Expressions


~ Begin P4Grammar

// expressions
e = true
  | false
  | a // arbitrary width integer literal
  | nwa // bit-width integer literal
  | nsa // int-width integer literal
  | uvw // string literal
  | x // name
  | .x //toplevel name
  | e1[e2] // array access
  | e1[e2:e3] // bit-string access
  | {e1,...,en} // list
  | uop e
  | e1 binop e2
  | (tau) e // explicit cast
  | tau.name // type member
  | ERROR.name // error member
  | e.name // expression member
  | e1 ? e2 : e3 // ternary operator
  | f<...,\tau_j,...>(...,ei,...)
  | f<...,\tau_j,...>(...,xi=ei,...)
  | tau(e1,...,en) // nameless instantiation
  | e1 &&& e2 // mask
  | e1 .. e2 // range

// unary operators
uop = ! // not
    | - // unary minus
    | ~ // bitwise complement/not

// binary operators
binop = +
      | |+|
      | -
      | |-|
      | *
      | /
      | %
      | <<
      | >>
      | <
      | >
      | <=
      | >=
      | ==
      | !=
      | &
      | ^
      | |
      | ++
      | &&
      | ||


// expression types
tau = bool
    | Error
    | int
    | int<e>
    | bit<e>
    | varbit<e>
    | topleveltype
    | f<...,X_j,...>(...,x_i:\tau_i,...) : \tau
    | X // type name
    | tau(tau1,...,taun) // specialized type
    | H[e] {f_1 : \tau_1, ... , f_n : \tau_n} // header stack
    | HU {f_1 : \tau_1, ... , f_n : \tau_n} // header union
    | enum X:\tau {m_1,...,m_n} // enum type
    | struct X {f_1 : \tau_1, ... , f_n : \tau_n}
    | extern X {...,m_i<X_1,...,X_n>(x_1:\tau_1,...,x_n:\tau_n) : \tau,...}
    | \{\tau_1,...,\tau_n\} // list type
    | tuple<\tau_1,...,\tau_n>
    | string
    | void
    | _ // don't care type

// directions
d = in
  | out
  | inout
  | none

~ End P4Grammar

# Static Semantics { #sec-static }

## Typing contexts

~ MathPre
\Pi : \mathsf{Var} -> \mathsf{Type}
G : \mathsf{Var} -> \mathsf{Type}
D : X -> t
~

## Typing judgments

<!--
need to add direction
-->

### Helper Rules

~ MathPre
numeric(t) = \begin{cases} true & t = int
true & t = int<w>
true & t = bit<w>
false & \text{otherwise}
\end{cases}
~

### Base Types

~ Infer

------------------------[Bool-True]
 \Pi,G,D |- true, none : bool
~

~ Infer

------------------------[Bool-False]
 \Pi,G,D |- false, none : bool
~

~ Infer

------------------------[String]
 \Pi,G,D |- u, none : string
~

~ Infer

------------------------[Int-Constant]
\Pi,G,D |- a, none : int
~

~ Infer

------------------------[Signed-Int-Constant]
\Pi,G,D |- nsa, none : int<w>
~

~ Infer

------------------------[Unsigned-Int-Constant]
\Pi,G,D |- nwa, none : bit<a>
~

### Variables

~ Infer
  G(x) = t
-------------------[Var]
\Pi,G,D |- x : t
~

~ Infer
  \Pi(x_{top}) = t
----------------------[Var-Top]
\Pi,G,D |- x_{top} : t
~

### Accesses

~ Infer
\Pi,G,D |- e_1 : t_1[], d_1
\Pi,G,D |- e_2  : t_2, \_
numeric(t_2)
----------------------[Array-Access]
\Pi,G,D |- e_1[e_2] : t_1, d_1
~

~ Infer
\Pi,G,D |- e_1 : bit<w>, d_1
\Pi,G,D |- e_2  : t_2 
numeric(t_2) 
\Pi,G,D |- e_3  : t_3 
numeric(t_3) 
0 \leq e_2 
e_2 < w 
e_2 \leq e_3 
e_3 < w
------------------------[Slice]
\Pi,G,D |- e1[e2:e3] : t_1, d_1
~

~ Infer
\Pi,G,D |- \overline{e: \tau, none}
-----------------------------------------------[List-Expression]
\Pi,G,D |- \{ \overline{e} \} : \{ \overline{\tau} \}, none
~

### Unary Operations

~ Infer
\Pi,G,D |- e : bool, d
-------------------[Not]
\Pi,G,D |- !e : bool, d
~

~ Infer
\Pi,G,D |- e : bit<w>, d
-----------------------------[Bitwise-Not]
\Pi,G,D |- {\texttt{\textasciitilde}e} : bit<w>, d
~

~ Infer
\Pi,G,D |- e : t, d
numeric(t)
--------------------[Negate]
\Pi,G,D |- {-e} : t, d
~

### Binary Operations

```haskell
  fun binaryDir In In = In
    | binaryDir _  _  = none
```

~ Infer
\Pi,G,D |- e_1 : bool, d_1
\Pi,G,D |- e_2 : bool, d_2
\diamond \in \{ \& \&,|| \}
--------------------------------------[Bool-Binary-Op]
\Pi,G,D |- e_1 \diamond e_2 : bool, binaryDir(d_1, d_2)
~

~ Infer
\Pi,G,D |- e_1 : int, d_1
\Pi,G,D |- e_2 : int, d_2
\diamond \in \{ +,-,*,<,>,\leq,\geq, /, \% \}
--------------------------------------------------------[Int-Binary-Op]
\Pi,G,D |- e_1 \diamond e_2 : int, binaryDir(d_1, d_2)
~

~ Infer
\Pi,G,D |- e_1 : int<w>, d_1
\Pi,G,D |- e_2 : int<w>, d_2
\diamond \in \{ +,-,*,<,>,\leq,\geq,|+|,|-| \}
-----------------------------------------------------------[Int-Signed-Binary-Op]
\Pi,G,D |- e_1 \diamond e_2 : int<w>, binaryDir(d_1, d_2)
~

<!--
having trouble with ^ symbol for xor
-->

~ Infer
\Pi,G,D |- e_1 : bit<w>, d_1
\Pi,G,D |- e_2 : bit<w>, d_2
\diamond \in \{ +,-,*,<,>,\leq,\geq,|+|,|-|,\&,|,\oplus \}
----------------------------------------------------------[Int-Unsigned-Binary-Op]
\Pi,G,D |- e_1 \diamond e_2 : bit<w>, binaryDir(d_1, d_2)
~

<!--
need to define has_equality
-->

~ Infer
\Pi,G,D |- e_1 : t, d_1
\Pi,G,D |- e_2 : t, d_2
has\_equality(t)
\diamond \in \{ ==,!= \}
----------------------------------------------------------[Equality-Op]
\Pi,G,D |- e_1 \diamond e_2 : bool, binaryDir(d_1, d_2)
~

~ Infer
\Pi,G,D |- e_1 : bit<l>, d_1
\Pi,G,D |- e_2 : bit<r>, d_2
---------------------------------[Bit-Concat-Op]
\Pi,G,D |- e_1 ++ e_2 : bit<l+r>, binaryDir(d_1, d_2)
~

~ Infer
\Pi,G,D |- e_1 : t_1, d_1
\Pi,G,D |- e_2 : t_2, d_2
numeric(t_1) 
t_2 = bit<\_> \lor t_2 int 
\diamond \in \{<<,>>\}
---------------------------------[Shift-Op]
\Pi,G,D |- e_1 \diamond e_2 : t_1, binaryDir(d_1, d_2)
~

### Casts

<!--
need to legal casts
-->

~ Infer
\Pi,G,D |- e : t', d
legal\_cast(t',t)
--------------------[Cast]
\Pi,G,D |- (t) e : t, d
~

### Member expressions

~ Infer
\Delta(X) = enum \, X: t \, \{m_1,...,m_n \}
m_i = name
--------------------[Error-Member]
\Pi, G, D |- X.name : t, none
~

~ Infer
ERROR.name \in dom(G)
--------------------[Error-Member]
\Pi,G,D |- ERROR.name : Error, none
~

~ Infer
\Pi,G,D |- e : H[n] \{f_1 : t_1, ... , f_n : t_n\}, d
\exists f_i = name
---------------------------------------------------[Header-Member]
\Pi,G,D |- e.name : t_i, d
~

~ Infer
\Pi,G,D |- e : HU \{f_1 : t_1, ... , f_n : t_n\}, d
\exists f_i = name
---------------------------------------------------[Header-Union-Member]
\Pi,G,D |- e.name : t_i, d
~

~ Infer
\Pi,G,D |- e : struct X \{f_1 : t_1, ... , f_n : t_n\}, d
\exists f_i = name
---------------------------------------------------[Struct-Member]
\Pi,G,D |- e.name : t_i, d
~

~ Infer
\Pi,G,D |- e : extern X \{...,m_i<X_1,...,X_n>(x_1:t_1,...,x_n:t_n) : t,...\}, d
\exists m_i = name
---------------------------------------------------[Extern-Member]
\Pi,G,D |- e.name : m_i<X_1,...,X_n>(x_1:t_1,...,x_n:t_n) : t, d
~

### Ternary Expression

~ Infer
\Pi,G,D |- e_1 : bool, \_
\Pi,G,D |- e_2 : t, \_
\Pi,G,D |- e_3 : t, \_
--------------------------------[Ternary-Op]
\Pi,G,D |- e_1 ? e_2 : e_3 : t, none
~

### Function Calls

~ Infer
\Pi, G, D |- f : f<...,X_i,...>(...,x_j:\tau_j,...) : \tau, \_
\forall j, \, \Pi,\Gamma,\Delta[...,X_i \to \tau_i,...] \vdash e_j : tau_j
----------------------------------------------------------------------------[Function-Call-Nameless]
\Pi,G,D |- f<...,\tau_i,...>(...,e_j,...) : \tau, none
~

~ Infer
\Pi,G,D |- f : f<...,X_i,...>(...,x_j:\tau_j,...) : \tau, \_
\forall j, \, \Pi,\Gamma,\Delta[...,X_i \to \tau_i,...] \vdash e_j : tau_j
----------------------------------------------------------------------------[Function-Call-Named]
\Pi,\Gamma,\Delta |- f<...,\tau_i,...>(...,x_j=e_j,...) : \tau,none
~

# Dynamic Semantics { #sec-dynamic }
