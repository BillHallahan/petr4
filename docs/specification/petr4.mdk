Title : Petr4 Semantics
Title Note: version 0.0.1
Title Footer: &date;
Author: The Petr4 Team
Heading depth: 5
Pdf Latex: xelatex
Document Class: [11pt]article
Package: [top=1in, bottom=1.25in, left=1in, right=1in]geometry
Package: fancyhdr
Package: mathpartir
Package: textcomp

.mathpre {
  replace: "/( +)\|-( +)/\1\vdash{}\2/g";
  replace: "/-\>/\to{}/g";
  replace: "/\bG\b/\Gamma{}/g";
  replace: "/\bD\b/\Delta{}/g";
  replace: "/\bt\b/\tau{}/g";
  replace: "/\bint<([^>]+)>/\texttt{int}\langle{}\1\rangle{}/g";
  replace: "/\bbit<([^>]+)>/\texttt{bit}\langle{}\1\rangle{}/g";
  replace: "/\bint\b/\texttt{int}/g";
  replace: "/\bbool\b/\texttt{bool}/g";
  replace: "/\btrue\b/\texttt{true}/g";
  replace: "/\bfalse\b/\texttt{false}/g";
  replace: "/\bstring\b/\texttt{string}/g";
}

Infer {
  replace:"/(\n|^)\n *----+ *\[([^\]]*)\] *\n([\s\S]*)/\
           \\infer{{}}{\3}{\textsc{\2}}/m";
  replace:"/([\s\S]*?)\n *----+ *\[([^\]]*)\] *\n([\s\S]*)/\
           \\infer{\1}{\3}{\textsc{\2}}/m";
  replace:"~ Begin MathPre {.infer}&nl;&nl;&source;&nl;\
           ~ End MathPre";
}

Tex Header:
  \setlength{\headheight}{30pt}
  \renewcommand{\footrulewidth}{0.5pt}

@if html {
body.madoko {
  font-family: utopia-std, serif;
}
title,titlenote,titlefooter,authors,h1,h2,h3,h4,h5 {
  font-family: helvetica, sans-serif;
  font-weight: bold;
}
pre, code {
  language: p4;
  font-family: monospace;
  font-size: 10pt;
}
}

@if tex {
body.madoko {
  font-family: UtopiaStd-Regular;
}
title,titlenote,titlefooter,authors {
  font-family: sans-serif;
  font-weight: bold;
}
pre, code {
  language: p4;
  font-family: LuxiMono;
  font-size: 75%;
}
}

Colorizer: p4
.token.keyword    {
    font-weight: bold;
}

@if html {
p4example {
  replace: "~ Begin P4ExampleBlock&nl;\
                 ````&nl;&source;&nl;````&nl;\
                 ~ End P4ExampleBlock";
  padding:6pt;
  margin-top: 6pt;
  margin-bottom: 6pt;
  border: solid;
  background-color: #ffffdd;
  border-width: 0.5pt;
}
}

@if tex {
p4example {
  replace: "~ Begin P4ExampleBlock&nl;\
                 ````&nl;&source;&nl;````&nl;\
                 ~ End P4ExampleBlock";
  breakable: true;
  padding: 6pt;
  margin-top: 6pt;
  margin-bottom: 6pt;
  border: solid;
  background-color: #ffffdd;
  border-width: 0.5pt;
}
}


@if html {
p4pseudo {
  replace: "~ Begin P4PseudoBlock&nl;\
                 ````&nl;&source;&nl;````&nl;\
                 ~ End P4PseudoBlock";
  padding: 6pt;
  margin-top: 6pt;
  margin-bottom: 6pt;
  border: solid;
  background-color: #e9fce9;
  border-width: 0.5pt;
}
}

@if tex {
p4pseudo {
  replace: "~ Begin P4PseudoBlock&nl;\
                 ````&nl;&source;&nl;````&nl;\
                 ~ End P4PseudoBlock";
  breakable : true;
  padding: 6pt;
  margin-top: 6pt;
  margin-bottom: 6pt;
  background-color: #e9fce9;
  border: solid;
  border-width: 0.5pt;
}
}

@if html {
p4grammar {
  replace: "~ Begin P4GrammarBlock&nl;\
                 ````&nl;&source;&nl;````&nl;\
                 ~ End P4GrammarBlock";
  border: solid;
  margin-top: 6pt;
  margin-bottom: 6pt;
  padding: 6pt;
  background-color: #e6ffff;
  border-width: 0.5pt;
}
}

@if tex {
p4grammar {
  replace: "~ Begin P4GrammarBlock&nl;\
                 ````&nl;&source;&nl;````&nl;\
                 ~ End P4GrammarBlock";
  breakable: true;
  margin-top: 6pt;
  margin-bottom: 6pt;
  padding: 6pt;
  background-color: #e6ffff;
  border: solid;
  border-width: 0.5pt;
}
}

[TITLE]

~ Begin Abstract
The goal of the Petr4 project is to define a formal semantics for the
P4 Programming Language.
~ End Abstract

[TOC]

# Introduction { #sec-introduction }
# Syntax { #sec-syntax }

## Expressions


~ Begin P4Grammar

// expressions
e = true
  | false
  | n // integer
  | string // string literal
  | x // name
  | x_{top} //toplevel name
  | e1[e2] // array access
  | e1[e2:e3] // bit-string access
  | {e1,...,en} // list
  | uop e
  | e1 binop e2
  | (tau) e // explicit cast
  | tau.name // type member
  | ERROR.name // error member
  | e.name // expression member
  | e1 ? e2 : e3 // ternary operator
  | f <X1,...,Xn>(e1,...,en)
  | f<X1,...,Xn>(x1=e1,...,xn=en)
  | tau(e1,...,en) // nameless instantiation
  | e1 &&& e2 // mask
  | e1 .. e2 // range

// unary operators
uop = ! // not
    | - // unary minus
    | ~ // bitwise complement/not

// binary operators
binop = +
      | |+|
      | -
      | |-|
      | *
      | /
      | %
      | <<
      | >>
      | <
      | >
      | <=
      | >=
      | ==
      | !=
      | &
      | ^
      | |
      | ++
      | &&
      | ||


// expression types
tau = bool
    | Error
    | int
    | int<e>
    | bit<e>
    | varbit<e>
    | topleveltype
    | f<X_1,...,X_n>(x_1:t_1,...,x_n:t_n) : t
    | X // type name
    | tau(tau1,...,taun) // specialized type
    | H[e] {f_1 : t_1, ... , f_n : t_n} // header stack
    | HU {f_1 : t_1, ... , f_n : t_n} // header union
    | struct X {f_1 : t_1, ... , f_n : t_n}
    | extern X {...,m_i<X_1,...,X_n>(x_1:t_1,...,x_n:t_n) : t,...}
    | \{t_1,...,t_n\} // list type
    | tuple<tau1,...,taun>
    | String
    | void
    | _ // don't care type

~ End P4Grammar

# Static Semantics { #sec-static }

## Typing contexts

~ MathPre
Top : \mathsf{Var} -> \mathsf{Type}
G : \mathsf{Var} -> \mathsf{Type}
D : X -> t
~

## Typing judgments

<!--
need to add direction
-->

### Helper Rules

~ MathPre
numeric(t) = \begin{cases} true & t = int
true & t = int<w>
true & t = bit<w>
false & \text{otherwise}
\end{cases}
~

### Base Types

~ Infer

------------------------[Bool-True]
 Top,G,D |- true : bool
~

~ Infer

------------------------[Bool-False]
 Top,G,D |- false : bool
~

~ Infer

------------------------[String]
 Top,G,D |- u : string
~

<!--
I'm not sure of the best way to judge integer literals...
seems ambiguous...
-->

~ Infer

------------------------[Int-Constant]
Top,G,D |- n : int
~

~ Infer

------------------------[Signed-Int-Constant]
Top,G,D |- n : int<w>
~

~ Infer

------------------------[Unsigned-Int-Constant]
Top,G,D |- n : bit<w>
~

### Variables

~ Infer
  G(x) = t
-------------------[Var]
Top,G,D |- x : t
~

~ Infer
  Top(x_{top}) = t
----------------------[Var-Top]
Top,G,D |- x_{top} : t
~

### Accesses

~ Infer
Top,G,D |- e_1 : t_1[]
Top,G,D |- e_2  : t_2
numeric(t_2)
----------------------[Array-Access]
Top,G,D |- e_1[e_2] : t_1
~

~ Infer
Top,G,D |- e_1 : bit<w> 
Top,G,D |- e_2  : t_2 
numeric(t_2) 
Top,G,D |- e_3  : t_3 
numeric(t_3) 
0 \leq e_2 
e_2 < w 
e_2  \leq e_3 
e_3 < w
------------------------[Slice]
Top,G,D |- e1[e2:e3] : t_1
~

~ Infer
Top,G,D |- \overline{e: \tau}
-----------------------------------------------[List-Expression]
Top,G,D |- \{ \overline{e} \} : \{ \overline{\tau} \}
~

### Unary Operations

~ Infer
Top,G,D |- e : bool
-------------------[Not]
Top,G,D |- !e : bool
~

~ Infer
Top,G,D |- e : bit<w>
-----------------------------[Bitwise-Not]
Top,G,D |- {\texttt{\textasciitilde}e} : bit<w>
~

~ Infer
Top,G,D |- e : t 
numeric(t)
--------------------[Negate]
Top,G,D |- {-e} : t
~

### Binary Operations

~ Infer
Top,G,D |- e_1 : bool 
Top,G,D |- e_2 : bool 
\diamond \in \{ \& \&,|| \}
--------------------------------------[Bool-Binary-Op]
Top,G,D |- e_1 \diamond e_2 : bool
~

~ Infer
Top,G,D |- e_1 : int 
Top,G,D |- e_2 : int 
\diamond \in \{ +,-,*,<,>,\leq,\geq, /, \% \}
-------------------------------------[Int-Binary-Op]
Top,G,D |- e_1 \diamond e_2 : int
~

~ Infer
Top,G,D |- e_1 : int<w> 
Top,G,D |- e_2 : int<w> 
\diamond \in \{ +,-,*,<,>,\leq,\geq,|+|,|-| \}
-------------------------------------[Int-Signed-Binary-Op]
Top,G,D |- e_1 \diamond e_2 : int<w>
~

<!--
having trouble with ^ symbol for xor
-->

~ Math
Top,G,D |- e_1 : bit<w> 
Top,G,D |- e_2 : bit<w> 
\diamond \in \{ +,-,*,<,>,\leq,\geq,|+|,|-|,\&,|,\oplus \}
----------------------------------------------------------[Int-Unsigned-Binary-Op]
Top,G,D |- e_1 \diamond e_2 : bit<w>
~

<!--
need to define has_equality
-->

~ Infer
Top,G,D |- e_1 : t_1 
Top,G,D |- e_2 : t_2 
t_1 = t_2 
has\_equality(t_1)
\diamond \in \{ ==,!= \}
----------------------------------------------------------[Equality-Op]
Top,G,D |- e_1 \diamond e_2 : bool
~

~ Infer
Top,G,D |- e_1 : bit<l> 
Top,G,D |- e_2 : bit<r> 
---------------------------------[Bit-Concat-Op]
Top,G,D |- e_1 ++ e_2 : bit<l+r>
~

~ Infer
Top,G,D |- e_1 : t_1 
Top,G,D |- e_2 : t_2 
numeric(t_1) 
t_2 = bit<\_> \lor t_2 int 
\diamond \in \{<<,>>\}
---------------------------------[Shift-Op]
Top,G,D |- e_1 \diamond e_2 : t_1
~

### Casts

<!--
need to legal casts
-->

~ Infer
Top,G,D |- e : t' 
legal\_cast(t',t)
--------------------[Cast]
Top,G,D |- (t) e : t
~

### Member expressions

~ Infer
ERROR.name \in dom(G)
--------------------[Error-Member]
Top,G,D |- ERROR.name : Error
~

~ Infer
Top,G,D |- e : H[n] \{f_1 : t_1, ... , f_n : t_n\} 
\exists f_i = name
---------------------------------------------------[Header-Member]
Top,G,D |- e.name : t_i
~

~ Infer
Top,G,D |- e : HU \{f_1 : t_1, ... , f_n : t_n\} 
\exists f_i = name
---------------------------------------------------[Header-Union-Member]
Top,G,D |- e.name : t_i
~

~ Infer
Top,G,D |- e : struct X \{f_1 : t_1, ... , f_n : t_n\} 
\exists f_i = name
---------------------------------------------------[Struct-Member]
Top,G,D |- e.name : t_i
~

~ Infer
Top,G,D |- e : extern X \{...,m_i<X_1,...,X_n>(x_1:t_1,...,x_n:t_n) : t,...\} 
\exists m_i = name
---------------------------------------------------[Extern-Member]
Top,G,D |- e.name : m_i<X_1,...,X_n>(x_1:t_1,...,x_n:t_n) : t
~

### Ternary Expression

~ Infer
Top,G,D |- e_1 : bool 
Top,G,D |- e_2 : t 
Top,G,D |- e_3 : t 
--------------------------------[Ternary-Op]
Top,G,D |- e_1 ? e_2 : e_3 : t
~

<!--
~ Math
\infer{}{}[function \, calls: \, named \, arguments]
~
-->

# Dynamic Semantics { #sec-dynamic }
