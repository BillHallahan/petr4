Title : Petr4 Semantics
Title Note: version 0.0.1
Title Footer: &date;
Author: The Petr4 Team
Heading depth: 5
Pdf Latex: xelatex
Document Class: [11pt]article
Package: [top=1in, bottom=1.25in, left=1in, right=1in]geometry
Package: fancyhdr
Package: mathpartir

infer {
replace:"/([\s\S]*?)\n *----+ *\[([^\]]*)\] *\n([\s\S]*)/\
\\infer{\1}{\3}{\textsc{\2}}/m";
replace:"~Begin MathPre {.infer}&nl;&nl;&source;&nl;\
~End MathPre";
}

Tex Header:
  \setlength{\headheight}{30pt}
  \renewcommand{\footrulewidth}{0.5pt}

@if html {
body.madoko {
  font-family: utopia-std, serif;
}
title,titlenote,titlefooter,authors,h1,h2,h3,h4,h5 {
  font-family: helvetica, sans-serif;
  font-weight: bold;
}
pre, code {
  language: p4;
  font-family: monospace;
  font-size: 10pt;
}
}

@if tex {
body.madoko {
  font-family: UtopiaStd-Regular;
}
title,titlenote,titlefooter,authors {
  font-family: sans-serif;
  font-weight: bold;
}
pre, code {
  language: p4;
  font-family: LuxiMono;
  font-size: 75%;
}
}

Colorizer: p4
.token.keyword    {
    font-weight: bold;
}

@if html {
p4example {
  replace: "~ Begin P4ExampleBlock&nl;\
                 ````&nl;&source;&nl;````&nl;\
                 ~ End P4ExampleBlock";
  padding:6pt;
  margin-top: 6pt;
  margin-bottom: 6pt;
  border: solid;
  background-color: #ffffdd;
  border-width: 0.5pt;
}
}

@if tex {
p4example {
  replace: "~ Begin P4ExampleBlock&nl;\
                 ````&nl;&source;&nl;````&nl;\
                 ~ End P4ExampleBlock";
  breakable: true;
  padding: 6pt;
  margin-top: 6pt;
  margin-bottom: 6pt;
  border: solid;
  background-color: #ffffdd;
  border-width: 0.5pt;
}
}


@if html {
p4pseudo {
  replace: "~ Begin P4PseudoBlock&nl;\
                 ````&nl;&source;&nl;````&nl;\
                 ~ End P4PseudoBlock";
  padding: 6pt;
  margin-top: 6pt;
  margin-bottom: 6pt;
  border: solid;
  background-color: #e9fce9;
  border-width: 0.5pt;
}
}

@if tex {
p4pseudo {
  replace: "~ Begin P4PseudoBlock&nl;\
                 ````&nl;&source;&nl;````&nl;\
                 ~ End P4PseudoBlock";
  breakable : true;
  padding: 6pt;
  margin-top: 6pt;
  margin-bottom: 6pt;
  background-color: #e9fce9;
  border: solid;
  border-width: 0.5pt;
}
}

@if html {
p4grammar {
  replace: "~ Begin P4GrammarBlock&nl;\
                 ````&nl;&source;&nl;````&nl;\
                 ~ End P4GrammarBlock";
  border: solid;
  margin-top: 6pt;
  margin-bottom: 6pt;
  padding: 6pt;
  background-color: #e6ffff;
  border-width: 0.5pt;
}
}

@if tex {
p4grammar {
  replace: "~ Begin P4GrammarBlock&nl;\
                 ````&nl;&source;&nl;````&nl;\
                 ~ End P4GrammarBlock";
  breakable: true;
  margin-top: 6pt;
  margin-bottom: 6pt;
  padding: 6pt;
  background-color: #e6ffff;
  border: solid;
  border-width: 0.5pt;
}
}

<!--
mathpre {
replace: "/\bt\b/\tau{}/g";
replace: "/\bG\b/\Gamma{}/g";
}

infer {
replace:"/([\s\S]*?)\n *----+ *\[([^\]]*)\] *\n([\s\S]*)/\
\\infer{\1}{\3}{\textsc{\2}}/m";
replace:"~Begin MathPre {.infer}&nl;&nl;&source;&nl;\
~End MathPre";
}
-->


[TITLE]

~ Begin Abstract
The goal of the Petr4 project is to define a formal semantics for the
P4 Programming Language.
~ End Abstract

[TOC]

# Introduction { #sec-introduction }
# Syntax { #sec-syntax }

## Expressions


~ Begin P4Grammar

// expressions
e = true
  | false
  | n // integer
  | string // string literal
  | x // name
  | x_{top} //toplevel name
  | e1[e2] // array access
  | e1[e2:e3] // bit-string access
  | {e1,...,en} // list
  | uop e
  | e1 binop e2
  | (tau) e // explicit cast
  | tau.name // type member
  | ERROR.name // error member
  | e.name // expression member
  | e1 ? e2 : e3 // ternary operator
  | f <X1,...,Xn>(e1,...,en)
  | f<X1,...,Xn>(x1=e1,...,xn=en)
  | tau(e1,...,en) // nameless instantiation
  | e1 &&& e2 // mask
  | e1 .. e2 // range

// unary operators
uop = ! // not
    | - // unary minus
    | ~ // bitwise complement/not

// binary operators
binop = +
      | |+|
      | -
      | |-|
      | *
      | /
      | %
      | <<
      | >>
      | <
      | >
      | <=
      | >=
      | ==
      | !=
      | &
      | ^
      | |
      | ++
      | &&
      | ||


// expression types
tau = bool
    | Error
    | int
    | int<e>
    | bit<e>
    | varbit<e>
    | topleveltype
    | f<X_1,...,X_n>(x_1:\tau_1,...,x_n:\tau_n) : \tau
    | X // type name
    | tau(tau1,...,taun) // specialized type
    | H[e] {f_1 : \tau_1, ... , f_n : \tau_n} // header stack
    | HU {f_1 : \tau_1, ... , f_n : \tau_n} // header union
    | struct X {f_1 : \tau_1, ... , f_n : \tau_n}
    | extern X {...,m_i<X_1,...,X_n>(x_1:\tau_1,...,x_n:\tau_n) : \tau,...}
    | \{\tau_1,...,\tau_n\} // list type
    | tuple<tau1,...,taun>
    | String
    | void
    | _ // don't care type

~ End P4Grammar

# Static Semantics { #sec-static }

## Typing contexts

~ Math
Top : x -> \tau \; \;
\Gamma : e -> \tau \; \;
\Delta : X -> \tau \; \;
~

## Typing judgments

<!--
need to add direction
-->

### Helper Rules

~ Math
\infer{
  \tau = int \lor
  \tau = int<\_> \lor
  \tau = bit<\_>
}{numeric(\tau)}[numeric]
~

### Base Types

~ Math
\infer{
}{Top,\Gamma,\Delta \vdash true : bool}[true]
~

~ Math
\infer{
}{Top,\Gamma,\Delta \vdash false : bool}[false]
~

~ Math
\infer{
}{Top,\Gamma,\Delta \vdash string : String}[string]
~

<!--
I'm not sure of the best way to judge integer literals...
seems ambiguous...
-->

~ Math
\infer{
}{Top,\Gamma,\Delta \vdash n : int}[int]
~

~ Math
\infer{
}{Top,\Gamma,\Delta \vdash n : int<w>}[int<w>]
~

~ Math
\infer{
}{Top,\Gamma,\Delta \vdash n : bit<w>}[bit<w>]
~

### Variables

~ Math
\infer{
  \Gamma(x) = \tau
}{Top,\Gamma,\Delta \vdash x : \tau}[name]
~

~ Math
\infer{
  Top(x_{top}) = \tau
}{Top,\Gamma,\Delta \vdash x_{top} : \tau}[name]
~

### Accesses

~ Math
\infer{
  Top,\Gamma,\Delta \vdash e_1 : \tau_1[] \\
  Top,\Gamma,\Delta \vdash e_2  : \tau_2 \\
  numeric(\tau_2)
}{Top,\Gamma,\Delta \vdash e_1[e_2] : \tau_1}[array \; access]
~

~ Math
\infer{
  Top,\Gamma,\Delta \vdash e_1 : bit<w> \\
  Top,\Gamma,\Delta \vdash e_2  : \tau_2 \\
  numeric(\tau_2) \\
  Top,\Gamma,\Delta \vdash e_3  : \tau_3 \\
  numeric(\tau_3) \\
  0 \leq e_2 \\
  e_2 < w \\
  e_2  \leq e_3 \\
  e_3 < w
}{Top,\Gamma,\Delta \vdash e1[e2:e3] : \tau_1}[bit \; string \; access]
~

~ Math
\infer{
  \forall i \in [0,n], \,
  Top,\Gamma,\Delta \vdash e_i : \tau_i
}{
  Top,\Gamma,\Delta \vdash \{e_1,...,e_n\} :
  \{\tau_1,...,\tau_n\}
}[list]
~

### Unary Operations

~ Math
\infer{
  Top,\Gamma,\Delta \vdash e : bool
}{
  Top,\Gamma,\Delta \vdash !e : bool
}[not]
~

<!--
not sure how to format tilde
-->

~ Math
\infer{
  Top,\Gamma,\Delta \vdash e : bit<w>
}{
  Top,\Gamma,\Delta \vdash \tilde e : bit<w>
}[bit \; not]
~

~ Math
\infer{
  Top,\Gamma,\Delta \vdash e : \tau \\
  numeric(\tau)
}{
  Top,\Gamma,\Delta \vdash -e : \tau
}[unary \; minus]
~

### Binary Operations

~ Math
\infer{
  Top,\Gamma,\Delta \vdash e_1 : bool \\
  Top,\Gamma,\Delta \vdash e_2 : bool \\
  \diamond \in \{ \& \&,|| \}
}{
  Top,\Gamma,\Delta \vdash e_1 \diamond e_2 : bool
}[and, \, or]
~

~ Math
\infer{
  Top,\Gamma,\Delta \vdash e_1 : int \\
  Top,\Gamma,\Delta \vdash e_2 : int \\
  \diamond \in \{ +,-,*,<,>,\leq,\geq, /, \% \}
}{
  Top,\Gamma,\Delta \vdash e_1 \diamond e_2 : int
}[binary \, int \, operations]
~

~ Math
\infer{
  Top,\Gamma,\Delta \vdash e_1 : int<w> \\
  Top,\Gamma,\Delta \vdash e_2 : int<w> \\
  \diamond \in \{ +,-,*,<,>,\leq,\geq,|+|,|-| \}
}{
  Top,\Gamma,\Delta \vdash e_1 \diamond e_2 : int<w>
}[binary \, fixed \, width \, int \, operations]
~

<!--
having trouble with ^ symbol for xor
-->

~ Math
\infer{
  Top,\Gamma,\Delta \vdash e_1 : bit<w> \\
  Top,\Gamma,\Delta \vdash e_2 : bit<w> \\
  \diamond \in \{ +,-,*,<,>,\leq,\geq,|+|,|-|,\&,|,\oplus \}
}{
  Top,\Gamma,\Delta \vdash e_1 \diamond e_2 : bit<w>
}[bit \, string \, binary \, operations]
~

<!--
need to define has_equality
-->

~ Math
\infer{
  Top,\Gamma,\Delta \vdash e_1 : \tau_1 \\
  Top,\Gamma,\Delta \vdash e_2 : \tau_2 \\
  \tau_1 = \tau_2 \\
  has\_equality(\tau_1)
  \diamond \in \{ ==,!= \}
}{
  Top,\Gamma,\Delta \vdash e_1 \diamond e_2 : bool
}[equality]
~

~ Math
\infer{
  Top,\Gamma,\Delta \vdash e_1 : bit<l> \\
  Top,\Gamma,\Delta \vdash e_2 : bit<r> \\
}{
  Top,\Gamma,\Delta \vdash e_1 ++ e_2 : bit<l+r>
}[concatenation]
~

~ Math
\infer{
  Top,\Gamma,\Delta \vdash e_1 : \tau_1 \\
  Top,\Gamma,\Delta \vdash e_2 : \tau_2 \\
  numeric(\tau_1) \\
  \tau_2 = bit<\_> \lor \tau_2 int \\
  \diamond \in \{<<,>>\}
}{
  Top,\Gamma,\Delta \vdash e_1 \diamond e_2 : \tau_1
}[shift]
~

### Casts

<!--
need to legal casts
-->

~ Math
\infer{
  Top,\Gamma,\Delta \vdash e : \tau' \\
  legal\_cast(\tau',\tau)
}{
  Top,\Gamma,\Delta \vdash (\tau) e : \tau
}[casts]
~

### Member expressions

~ Math
\infer{
  ERROR.name \in dom(\Gamma)
}{
  Top,\Gamma,\Delta \vdash ERROR.name : Error
}[error \, member]
~

~ Math
\infer{
  Top,\Gamma,\Delta \vdash e : H[n] \{f_1 : \tau_1, ... , f_n : \tau_n\} \\
  \exists f_i = name
}{
  Top,\Gamma,\Delta \vdash e.name : \tau_i
}[header \, member]
~

~ Math
\infer{
  Top,\Gamma,\Delta \vdash e : HU \{f_1 : \tau_1, ... , f_n : \tau_n\} \\
  \exists f_i = name
}{
  Top,\Gamma,\Delta \vdash e.name : \tau_i
}[header \, union \, member]
~

~ Math
\infer{
  Top,\Gamma,\Delta \vdash e : struct X \{f_1 : \tau_1, ... , f_n : \tau_n\} \\
  \exists f_i = name
}{
  Top,\Gamma,\Delta \vdash e.name : \tau_i
}[struct \, member]
~

~ Math
\infer{
  Top,\Gamma,\Delta \vdash e : extern X \{...,m_i<X_1,...,X_n>(x_1:\tau_1,...,x_n:\tau_n) : \tau,...\} \\
  \exists m_i = name
}{
  Top,\Gamma,\Delta \vdash e.name : m_i<X_1,...,X_n>(x_1:\tau_1,...,x_n:\tau_n) : \tau
}[extern \, member]
~

### Ternary Expression

~ Math
\infer{
  Top,\Gamma,\Delta \vdash e_1 : bool \\
  Top,\Gamma,\Delta \vdash e_2 : \tau \\
  Top,\Gamma,\Delta \vdash e_3 : \tau \\
}{
  Top,\Gamma,\Delta \vdash e_1 ? e_2 : e_3 : \tau
}[ternary]
~

<!--
~ Math
\infer{}{}[function \, calls: \, named \, arguments]
~
-->

# Dynamic Semantics { #sec-dynamic }
