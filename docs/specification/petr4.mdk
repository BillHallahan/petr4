Title : Petr4 Semantics
Title Note: version 0.0.1
Title Footer: &date;
Author: The Petr4 Team
Heading depth: 5
Pdf Latex: xelatex
Document Class: [11pt]article
Package: [top=1in, bottom=1.25in, left=1in, right=1in]geometry
Package: fancyhdr
Package: mathpartir
Package: textcomp

.mathpre {
  replace: "/( +)\|-( +)/\1\vdash{}\2/g";
  replace: "/-\>/\to{}/g";
  replace: "/\bG\b/\Gamma{}/g";
  replace: "/\bD\b/\Delta{}/g";
  replace: "/\bt([^a-z])/\tau{}\1/g";
  replace: "/\bint\b/\texttt{int}/g";
  replace: "/\bbit\b/\texttt{bit}/g";
  replace: "/\bvarbit\b/\texttt{varbit}/g";
  replace: "/\btuple\b/\texttt{tuple}/g";
  replace: "/\bset\b/\texttt{set}/g";
  replace: "/\berror\b/\texttt{error}/g";
  replace: "/\bmatch_kind\b/\texttt{match\_kind}/g";
  replace: "/\bset\b/\texttt{set}/g";
  replace: "/\bvoid\b/\texttt{void}/g";
  replace: "/\bheader union\b/\texttt{header union}/g";
  replace: "/\bheader(?! union)\b/\texttt{header}/g";
  replace: "/\bstruct\b/\texttt{struct}/g";
  replace: "/\benum\b/\texttt{enum}/g";
  replace: "/\bpackage\b/\texttt{package}/g";
  replace: "/\bcontrol\b/\texttt{control}/g";
  replace: "/\bparser\b/\texttt{parser}/g";
  replace: "/\bextern\b/\texttt{extern}/g";
  replace: "/\bfunction\b/\texttt{function}/g";
  replace: "/\baction\b/\texttt{action}/g";
  replace: "/\btable\b/\texttt{table}/g";
  replace: "/</\langle{}/g";
  replace: "/>/\rangle{}/g";
  replace: "/\bbool\b/\texttt{bool}/g";
  replace: "/\btrue\b/\texttt{true}/g";
  replace: "/\bfalse\b/\texttt{false}/g";
  replace: "/\bstring\b/\texttt{string}/g";
}

Infer {
  replace:"/(\n|^)\n *----+ *\[([^\]]*)\] *\n([\s\S]*)/\
           \\infer{{}}{\3}{\textsc{\2}}/m";
  replace:"/([\s\S]*?)\n *----+ *\[([^\]]*)\] *\n([\s\S]*)/\
           \\infer{\1}{\3}{\textsc{\2}}/m";
  replace:"~ Begin MathPre {.infer}&nl;&nl;&source;&nl;\
           ~ End MathPre";
}

Tex Header:
  \setlength{\headheight}{30pt}
  \renewcommand{\footrulewidth}{0.5pt}

@if html {
body.madoko {
  font-family: utopia-std, serif;
}
title,titlenote,titlefooter,authors,h1,h2,h3,h4,h5 {
  font-family: helvetica, sans-serif;
  font-weight: bold;
}
pre, code {
  language: p4;
  font-family: monospace;
  font-size: 10pt;
}
}

@if tex {
body.madoko {
  font-family: UtopiaStd-Regular;
}
title,titlenote,titlefooter,authors {
  font-family: sans-serif;
  font-weight: bold;
}
pre, code {
  language: p4;
  font-family: LuxiMono;
  font-size: 75%;
}
}

Colorizer: p4
.token.keyword    {
    font-weight: bold;
}

@if html {
p4example {
  replace: "~ Begin P4ExampleBlock&nl;\
                 ````&nl;&source;&nl;````&nl;\
                 ~ End P4ExampleBlock";
  padding:6pt;
  margin-top: 6pt;
  margin-bottom: 6pt;
  border: solid;
  background-color: #ffffdd;
  border-width: 0.5pt;
}
}

@if tex {
p4example {
  replace: "~ Begin P4ExampleBlock&nl;\
                 ````&nl;&source;&nl;````&nl;\
                 ~ End P4ExampleBlock";
  breakable: true;
  padding: 6pt;
  margin-top: 6pt;
  margin-bottom: 6pt;
  border: solid;
  background-color: #ffffdd;
  border-width: 0.5pt;
}
}


@if html {
p4pseudo {
  replace: "~ Begin P4PseudoBlock&nl;\
                 ````&nl;&source;&nl;````&nl;\
                 ~ End P4PseudoBlock";
  padding: 6pt;
  margin-top: 6pt;
  margin-bottom: 6pt;
  border: solid;
  background-color: #e9fce9;
  border-width: 0.5pt;
}
}

@if tex {
p4pseudo {
  replace: "~ Begin P4PseudoBlock&nl;\
                 ````&nl;&source;&nl;````&nl;\
                 ~ End P4PseudoBlock";
  breakable : true;
  padding: 6pt;
  margin-top: 6pt;
  margin-bottom: 6pt;
  background-color: #e9fce9;
  border: solid;
  border-width: 0.5pt;
}
}

@if html {
p4grammar {
  replace: "~ Begin P4GrammarBlock&nl;\
                 ````&nl;&source;&nl;````&nl;\
                 ~ End P4GrammarBlock";
  border: solid;
  margin-top: 6pt;
  margin-bottom: 6pt;
  padding: 6pt;
  background-color: #e6ffff;
  border-width: 0.5pt;
}
}

@if tex {
p4grammar {
  replace: "~ Begin P4GrammarBlock&nl;\
                 ````&nl;&source;&nl;````&nl;\
                 ~ End P4GrammarBlock";
  breakable: true;
  margin-top: 6pt;
  margin-bottom: 6pt;
  padding: 6pt;
  background-color: #e6ffff;
  border: solid;
  border-width: 0.5pt;
}
}

p4mathgrammar {
  replace:"/\/\/(.*)/\/\/ &\text{\1}/g";
  replace: "~ Begin P4MathGrammarBlock&nl;\
                 ~ Begin MathPre&nl;&source;&nl;~ End MathPre&nl;\
                 ~ End P4MathGrammarBlock";
  breakable: true;
  margin-top: 6pt;
  margin-bottom: 6pt;
  padding: 6pt;
  background-color: #e6ffff;
  border: solid;
  border-width: 0.5pt;
}

[TITLE]

~ Begin Abstract
The goal of the Petr4 project is to define a formal semantics for the
P4 Programming Language.
~ End Abstract

[TOC]

# Introduction { #sec-introduction }
# Syntax { #sec-syntax }

## Expressions

~ Begin P4MathGrammar
e = true
  | false
  | a // arbitrary width integer literal
  | nwa // unsigned integer literal
  | nsa // signed integer literal
  | u // strings
  | x // name
  | .x // top level name
  | e1[e2] // array access
  | e1[e2:e3] // bitslice
  | {e1,...,en} // list
  | uop e
  | e1 binop e2
  | (t) e // explicit cast
  | X.name // type member
  | error.name // errors
  | e.name // expression member
  | e1 ? e2 : e3 // ternary operator
  | f<...,\tau_j,...>(...,ei,...)
  | f<...,\tau_j,...>(...,xi=ei,...)
  | t(e1,...,en) // nameless instantiation
  | e1 \texttt{\&\&\&} e2 // mask
  | e1 .. e2 // range
~ End P4MathGrammar

~ Begin P4Grammar
// unary operators
uop = ! // not
    | - // unary minus
    | ~ // bitwise complement/not

// binary operators
binop = +
      | |+|
      | -
      | |-|
      | *
      | /
      | %
      | <<
      | >>
      | <
      | >
      | <=
      | >=
      | ==
      | !=
      | &
      | ^
      | |
      | ++
      | &&
      | ||
~ End P4Grammar

~ Begin P4MathGrammar
// constructors
C = PackageType
  | Parser
  | Control
  | Extern
~ End P4MathGrammar

~ Begin P4MathGrammar
// types
t = bool
  | string
  | int
  | int<a>
  | bit<a>
  | varbit<a>
  | \tau[a]
  | tuple<\tau_1, ..., \tau_n>
  | \{\tau_1,...,\tau_n\}
  | set<\tau>
  | error
  | match_kind
  | X  // type name
  | .X // top level type reference
  | void
  | header X {f_1: \tau_1, ..., f_n: \tau_n}
  | header union X {f_1: \tau_1, ..., f_n: \tau_n}
  | struct X {f_1: \tau_1, ..., f_n: \tau_n}
  | enum X {m_1, ..., m_n}
  | enum \tau X {m_1, ..., m_n}
  | t<t_1, ..., t_n) // specialized type
  | package(x_1: t_1, ..., x_n: t_n)
  | control <t_1,...,t_n> (...)
  | parser <t_1,...,t_n> (...)
  | extern X {...,m_i<X_1,...,X_n>(x_1:\tau_1,...,x_n:\tau_n) : \tau,...}
  | function<X_1, ..., X_m>(x_1: \tau_1, ..., x_n: \tau_n) : \tau
  | action<X_1, ..., X_m>(x_1: \tau_1, ..., x_n: \tau_n) : \tau
  | table (...)

// directions
d = in
  | out
  | inout
  | none

~ End P4MathGrammar

## Values

<!--
where does this belong in the doc?

TODO:
- decl and stmt already defined?
- lvalues?
-->
We assume the existence of the sets name and loc, for variable names and memory locations respectively.

$a \in \mathbb{Z}$

$n \in \mathbb{N}$

$u^n \in \mathbb{Z}_n$ <!-- integers mod n, ax - should be mod 2^n? -->

$w^n \in \mathbb{Z}_{n-1} \cup \{ x | -x\in \mathbb{Z}_n\}$

~ Begin P4Grammar

// values
v ::= null // TODO: do we need? stp - probably not
    | b // bool
    | a // arbitrary-width integer
    | (n, u^n) // bit-width integer, n <> 0
    | (n, w^n) // int-width integer, n <> 0
    | (n, n’, u^n’) // variable-size bitstring, n’ <= n
    | s // string
    | (v1,...,vn) // tuple
    | S // set
    | \texttt{error}.name // error
    | (p1,...,pn) => block // function, action TODO: define block
    | name // builtin function
    | action ?? // stp - should be able to overload the function case
    | name \rightharpoonup v // struct
    | (name \rightharpoonup v, b) // header
    | (name \rightharpoonup b, v) // union
    | (v1,...,vn, n1, n2) //stack
    | name1.name2 // enumfield
    | (name1.name2, v) // senumfield
    | loc // stateful runtime
    | (name \upharpoonright v, (p1,...,pn), [decl1;...;declm],
      [\delta1;...;\deltan]) // parsers
    | (name \upharpoonright v, (p1,...,pn), [decl1;...;declm], block)
      //block
    | name \upharpoonright v // package
    | (name, (v1,...,vn), (vn+1,...,vn+m), vn+m+1,
      ((S1,vn+m+2),...,(SN,vn+m+N+2)) // table, best way to clean up the numbering?
    | extern name // externfun

// sets
S ::=  _ // universal
    | v // singleton
    | v1 &&& v2 // mask
    | v1 .. v2 // range
    | (S1,...,Sn) // product
    | lpm v // lpm, TODO: separate sets and matchkinds? nbits is runtime value so this is same as singleton
    | ?? // TODO: value set

// parameters
p ::= (d, \tau, v)

// transitions
t ::= name // transitions
    | ((e1,...,en), S \rightharpoonup name)

// parser state
\delta ::= (name, [stmt1;...;stmtn], t)


~ End P4Grammar

# Static Semantics { #sec-static }

## Typing contexts

~ MathPre
\Pi : \mathsf{Var} -> \mathsf{Type}
G : \mathsf{Var} -> \mathsf{Type}
D : X -> t
~

## Typing judgments

<!--
need to add direction
-->

### Helper Rules

~ MathPre
numeric(t) = \begin{cases} true & t = int
true & t = int<w>
true & t = bit<w>
false & \text{otherwise}
\end{cases}
~

### Base Types

~ Infer

------------------------[Bool-True]
 \Pi,G,D |- true : bool, none
~

~ Infer

------------------------[Bool-False]
 \Pi,G,D |- false : bool, none
~

~ Infer

------------------------[String]
 \Pi,G,D |- u : string, none
~

~ Infer

------------------------[Int-Constant]
\Pi,G,D |- a : int, none
~

~ Infer

------------------------[Signed-Int-Constant]
\Pi,G,D |- nsa : int<w>, none
~

~ Infer

------------------------[Unsigned-Int-Constant]
\Pi,G,D |- nwa : bit<a>, none
~

### Variables

~ Infer
G(x) = t, d
-------------------[Var]
\Pi,G,D |- x : t, d
~

~ Infer
\Pi(x) = t, d
----------------------[Var-Top]
\Pi,G,D |- .x : t, d
~

### Accesses

~ Infer
\Pi,G,D |- e_1 : t_1[], d_1
\Pi,G,D |- e_2  : t_2, \_
numeric(t_2)
----------------------[Array-Access]
\Pi,G,D |- e_1[e_2] : t_1, d_1
~

~ Infer
\Pi,G,D |- e_1 : bit<w>, d_1
\Pi,G,D |- e_2  : t_2, \_
numeric(t_2)
\Pi,G,D |- e_3  : t_3, \_
numeric(t_3)
0 \leq e_2
e_2 \lt w
e_2 \leq e_3
e_3 \lt w
------------------------[Slice]
\Pi,G,D |- e1[e2:e3] : t_1, d_1
~

~ Infer
\Pi,G,D |- \overline{e: \tau, none}
-----------------------------------------------[List-Expression]
\Pi,G,D |- \{ \overline{e} \} : \{ \overline{\tau} \}, none
~

### Unary Operations

~ Infer
\Pi,G,D |- e : bool, d
-------------------[Not]
\Pi,G,D |- !e : bool, d
~

~ Infer
\Pi,G,D |- e : bit<w>, d
-----------------------------[Bitwise-Not]
\Pi,G,D |- {\texttt{\textasciitilde}e} : bit<w>, d
~

~ Infer
\Pi,G,D |- e : t, d
numeric(t)
--------------------[Negate]
\Pi,G,D |- {-e} : t, d
~

### Binary Operations

```haskell
  fun binaryDir In In = In
    | binaryDir _  _  = none

  fun implicitCast bit<w> int = bit<w>
    | implicitCast int<w> int = int<w>
    | implicitCast int bit<w> = bit<w>
    | implicitCast int int<w> = int<w>
```

~ Infer
\Pi,G,D |- e_1 : bool, d_1
\Pi,G,D |- e_2 : bool, d_2
\diamond \in \{ \& \&,|| \}
--------------------------------------[Bool-Binary-Op]
\Pi,G,D |- e_1 \mathbin{\diamond} e_2 : bool, binaryDir(d_1, d_2)
~

~ Infer
\Pi,G,D |- e_1 : int, d_1
\Pi,G,D |- e_2 : int, d_2
\diamond \in \{ +,-,*,<,>,\leq,\geq, /, \% \}
--------------------------------------------------------[Int-Binary-Op]
\Pi,G,D |- e_1 \mathbin{\diamond} e_2 : int, binaryDir(d_1, d_2)
~

~ Infer
\Pi,G,D |- e_1 : \tau_1, d_1
\Pi,G,D |- e_2 : \tau_2, d_2
implicitCast(\tau_1,\tau_2) = int<w>
\diamond \in \{ +,-,*,<,>,\leq,\geq,|+|,|-| \}
-----------------------------------------------------------[Int-Signed-Binary-Op]
\Pi,G,D |- e_1 \mathbin{\diamond} e_2 : int<w>, binaryDir(d_1, d_2)
~

<!--
having trouble with ^ symbol for xor
-->

~ Infer
\Pi,G,D |- e_1 : \tau_1, d_1
\Pi,G,D |- e_2 : \tau_2, d_2
implicitCast(\tau_1,\tau_2) = bit<w>
\diamond \in \{ +,-,*,<,>,\leq,\geq,|+|,|-|,\&,|,\oplus \}
----------------------------------------------------------[Int-Unsigned-Binary-Op]
\Pi,G,D |- e_1 \mathbin{\diamond} e_2 : bit<w>, binaryDir(d_1, d_2)
~

<!--
need to define has_equality
-->

~ Infer
\Pi,G,D |- e_1 : t, d_1
\Pi,G,D |- e_2 : t, d_2
has\_equality(t)
\diamond \in \{ ==,!= \}
----------------------------------------------------------[Equality-Op]
\Pi,G,D |- e_1 \mathbin{\diamond} e_2 : bool, binaryDir(d_1, d_2)
~

~ Infer
\Pi,G,D |- e_1 : bit<l>, d_1
\Pi,G,D |- e_2 : bit<r>, d_2
---------------------------------[Bit-Concat-Op]
\Pi,G,D |- e_1 \mathbin{++} e_2 : bit<l+r>, binaryDir(d_1, d_2)
~

~ Infer
\Pi,G,D |- e_1 : t_1, d_1
\Pi,G,D |- e_2 : t_2, d_2
numeric(t_1)
t_2 = bit<\_> \lor t_2 = int
\diamond \in \{\ll, \gg\}
---------------------------------[Shift-Op]
\Pi,G,D |- e_1 \mathbin{\diamond} e_2 : t_1, binaryDir(d_1, d_2)
~

### Casts

<!--
need to legal casts
-->

~ Infer
\Pi,G,D |- e : t_0, d
legal\_cast(t_0,t)
------------------------[Cast]
\Pi,G,D |- (t) e : t, d
~

### Member expressions

~ Infer
\Delta(X) = enum \, X: t \, \{m_1,...,m_n \}
m_i = name
--------------------[Type-Member]
\Pi, G, D |- X.name : t, none
~

~ Infer
error.name \in dom(G)
--------------------[Error-Member]
\Pi,G,D |- error.name : error, none
~

~ Infer
\Pi,G,D |- e : H[n] \{f_1 : t_1, ... , f_n : t_n\}, d
\exists f_i = name
---------------------------------------------------[Header-Member]
\Pi,G,D |- e.name : t_i, d
~

~ Infer
\Pi,G,D |- e : HU \{f_1 : t_1, ... , f_n : t_n\}, d
\exists f_i = name
---------------------------------------------------[Header-Union-Member]
\Pi,G,D |- e.name : t_i, d
~

~ Infer
\Pi,G,D |- e : struct X \{f_1 : t_1, ... , f_n : t_n\}, d
\exists f_i = name
---------------------------------------------------[Struct-Member]
\Pi,G,D |- e.name : t_i, d
~

~ Infer
\Pi,G,D |- e : extern X \{...,m_i<X_1,...,X_n>(x_1:t_1,...,x_n:t_n) : t,...\}, d
\exists m_i = name
---------------------------------------------------[Extern-Member]
\Pi,G,D |- e.name : m_i<X_1,...,X_n>(x_1:t_1,...,x_n:t_n) : t, d
~

### Ternary Expression

~ Infer
\Pi,G,D |- e_1 : bool, \_
\Pi,G,D |- e_2 : t, \_
\Pi,G,D |- e_3 : t, \_
--------------------------------[Ternary-Op]
\Pi,G,D |- e_1 ? e_2 : e_3 : t, none
~

### Function Calls

~ Infer
\Pi, G, D |- f : f<\overline{X}>(\overline{x: t}) : t_{\mathsf{ret}}, \_
\Pi,\Gamma,\Delta[\overline{X \to \rho}] \vdash \overline{e : t}
----------------------------------------------------------------------------[Function-Call-Nameless]
\Pi,G,D |- f<\overline{\rho}>(\overline{e}) : \tau_{\mathsf{ret}}, none
~

~ Infer
\Pi,G,D |- f : f<...,X_i,...>(...,x_j:\tau_j,...) : \tau, \_
\forall j, \, \Pi,\Gamma,\Delta[...,X_i \to \tau_i,...] \vdash e_j : tau_j
----------------------------------------------------------------------------[Function-Call-Named]
\Pi,\Gamma,\Delta |- f<...,\tau_i,...>(...,x_j=e_j,...) : \tau,none
~

### Nameless Instantiation

<!--
C will refer to constructors
-->

<!--
TODO
this rule is incomplete
-->

~ Infer
C \in dom(\Pi)
\forall i, \Pi,G,D |- e_i : \tau_i
---------------------------------------------------[Specialized-Type-Instantiation]
\Pi,G,D |- C(...,\tau_j,...)(...,e_i,...) : C(...,\tau_j,...),none
~

### Set Operations

~ Infer
\Pi,G,D |- e_1 : bit<w>, \_
\Pi,G,D |- e_2 : bit<w>, \_
------------------------------------------------[Masks]
\Pi,G,D |- e_1 &&& e_2 : set<bit<w>>,none
~

~ Infer
\Pi,G,D |- e_1 : \tau, \_
\Pi,G,D |- e_2 : \tau, \_
\tau = bit<w> \lor \tau = int<w>
-------------------------[Ranges]
\Pi,G,D |- e_1 .. e_2 : set<\tau>, none
~

# Dynamic Semantics { #sec-dynamic }

## Expressions

$\langle e, ctrl, env, st \Downarrow_e env', st', v \rangle$
