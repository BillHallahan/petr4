Title : Petr4 Semantics
Title Note: version 0.0.1
Title Footer: &date;
Author: The Petr4 Team
Heading depth: 5
Pdf Latex: xelatex
Document Class: [11pt]article
Package: [top=1in, bottom=1.25in, left=1in, right=1in]geometry
Package: fancyhdr
Package: mathpartir

infer {
replace:"/([\s\S]*?)\n *----+ *\[([^\]]*)\] *\n([\s\S]*)/\
\\infer{\1}{\3}{\textsc{\2}}/m";
replace:"~Begin MathPre {.infer}&nl;&nl;&source;&nl;\
~End MathPre";
}

Tex Header:
  \setlength{\headheight}{30pt}
  \renewcommand{\footrulewidth}{0.5pt}

@if html {
body.madoko {
  font-family: utopia-std, serif;
}
title,titlenote,titlefooter,authors,h1,h2,h3,h4,h5 {
  font-family: helvetica, sans-serif;
  font-weight: bold;
}
pre, code {
  language: p4;
  font-family: monospace;
  font-size: 10pt;
}
}

@if tex {
body.madoko {
  font-family: UtopiaStd-Regular;
}
title,titlenote,titlefooter,authors {
  font-family: sans-serif;
  font-weight: bold;
}
pre, code {
  language: p4;
  font-family: LuxiMono;
  font-size: 75%;
}
}

Colorizer: p4
.token.keyword    {
    font-weight: bold;
}

@if html {
p4example {
  replace: "~ Begin P4ExampleBlock&nl;\
                 ````&nl;&source;&nl;````&nl;\
                 ~ End P4ExampleBlock";
  padding:6pt;
  margin-top: 6pt;
  margin-bottom: 6pt;
  border: solid;
  background-color: #ffffdd;
  border-width: 0.5pt;
}
}

@if tex {
p4example {
  replace: "~ Begin P4ExampleBlock&nl;\
                 ````&nl;&source;&nl;````&nl;\
                 ~ End P4ExampleBlock";
  breakable: true;
  padding: 6pt;
  margin-top: 6pt;
  margin-bottom: 6pt;
  border: solid;
  background-color: #ffffdd;
  border-width: 0.5pt;
}
}


@if html {
p4pseudo {
  replace: "~ Begin P4PseudoBlock&nl;\
                 ````&nl;&source;&nl;````&nl;\
                 ~ End P4PseudoBlock";
  padding: 6pt;
  margin-top: 6pt;
  margin-bottom: 6pt;
  border: solid;
  background-color: #e9fce9;
  border-width: 0.5pt;
}
}

@if tex {
p4pseudo {
  replace: "~ Begin P4PseudoBlock&nl;\
                 ````&nl;&source;&nl;````&nl;\
                 ~ End P4PseudoBlock";
  breakable : true;
  padding: 6pt;
  margin-top: 6pt;
  margin-bottom: 6pt;
  background-color: #e9fce9;
  border: solid;
  border-width: 0.5pt;
}
}

@if html {
p4grammar {
  replace: "~ Begin P4GrammarBlock&nl;\
                 ````&nl;&source;&nl;````&nl;\
                 ~ End P4GrammarBlock";
  border: solid;
  margin-top: 6pt;
  margin-bottom: 6pt;
  padding: 6pt;
  background-color: #e6ffff;
  border-width: 0.5pt;
}
}

@if tex {
p4grammar {
  replace: "~ Begin P4GrammarBlock&nl;\
                 ````&nl;&source;&nl;````&nl;\
                 ~ End P4GrammarBlock";
  breakable: true;
  margin-top: 6pt;
  margin-bottom: 6pt;
  padding: 6pt;
  background-color: #e6ffff;
  border: solid;
  border-width: 0.5pt;
}
}

<!--
mathpre {
replace: "/\bt\b/\tau{}/g";
replace: "/\bG\b/\Gamma{}/g";
}

infer {
replace:"/([\s\S]*?)\n *----+ *\[([^\]]*)\] *\n([\s\S]*)/\
\\infer{\1}{\3}{\textsc{\2}}/m";
replace:"~Begin MathPre {.infer}&nl;&nl;&source;&nl;\
~End MathPre";
}
-->


[TITLE]

~ Begin Abstract
The goal of the Petr4 project is to define a formal semantics for the
P4 Programming Language.
~ End Abstract

[TOC]

# Introduction { #sec-introduction }
# Syntax { #sec-syntax }

## Expressions


~ Begin P4Grammar

// expressions
e = true
  | false
  | a // arbitrary width integer literal
  | nwa // bit-width integer literal
  | nsa // int-width integer literal
  | uvw // string literal
  | x // name
  | .x //toplevel name
  | e1[e2] // array access
  | e1[e2:e3] // bit-string access
  | {e1,...,en} // list
  | uop e
  | e1 binop e2
  | (tau) e // explicit cast
  | tau.name // type member
  | ERROR.name // error member
  | e.name // expression member
  | e1 ? e2 : e3 // ternary operator
  | f <X1,...,Xn>(e1,...,en)
  | f<X1,...,Xn>(x1=e1,...,xn=en)
  | tau(e1,...,en) // nameless instantiation
  | e1 &&& e2 // mask
  | e1 .. e2 // range

// unary operators
uop = ! // not
    | - // unary minus
    | ~ // bitwise complement/not

// binary operators
binop = +
      | |+|
      | -
      | |-|
      | *
      | /
      | %
      | <<
      | >>
      | <
      | >
      | <=
      | >=
      | ==
      | !=
      | &
      | ^
      | |
      | ++
      | &&
      | ||


// expression types
tau = bool
    | Error
    | int
    | int<e>
    | bit<e>
    | varbit<e>
    | topleveltype
    | f<X_1,...,X_n>(x_1:\tau_1,...,x_n:\tau_n) : \tau
    | X // type name
    | tau(tau1,...,taun) // specialized type
    | H[e] {f_1 : \tau_1, ... , f_n : \tau_n} // header stack
    | HU {f_1 : \tau_1, ... , f_n : \tau_n} // header union
    | enum X:\tau {m_1,...,m_n} // enum type
    | struct X {f_1 : \tau_1, ... , f_n : \tau_n}
    | extern X {...,m_i<X_1,...,X_n>(x_1:\tau_1,...,x_n:\tau_n) : \tau,...}
    | \{\tau_1,...,\tau_n\} // list type
    | tuple<tau1,...,taun>
    | string
    | void
    | _ // don't care type

// directions
d = in
  | out
  | inout
  | none

~ End P4Grammar

# Static Semantics { #sec-static }

## Typing contexts

~ Math
\Pi : .x -> \tau,d \; \;
\Gamma : x -> \tau,d \; \;
\Delta : X -> \tau \; \;
~

## Typing judgments

<!--
need to add direction
-->

### Helper Rules

~ Math
\infer{
  \tau = int \lor
  \tau = int<\_> \lor
  \tau = bit<\_>
}{numeric(\tau)}[numeric]
~

### Base Types

~ Math
\infer{
}{\Pi,\Gamma,\Delta \vdash true,none : bool}[true]
~

~ Math
\infer{
}{\Pi,\Gamma,\Delta \vdash false,none : bool}[false]
~

~ Math
\infer{
}{\Pi,\Gamma,\Delta \vdash uvw,none : string}[string]
~

~ Math
\infer{
}{\Pi,\Gamma,\Delta \vdash a,none : int}[int]
~

~ Math
\infer{
}{\Pi,\Gamma,\Delta \vdash nsa,none : int<a>}[int<a>]
~

~ Math
\infer{
}{\Pi,\Gamma,\Delta \vdash nwa,none : bit<a>}[bit<a>]
~

### Variables

~ Math
\infer{
  \Gamma(x) = \tau,d
}{\Pi,\Gamma,\Delta \vdash x,d : \tau}[name]
~

~ Math
\infer{
  \Pi(.x) = \tau,d
}{\Pi,\Gamma,\Delta \vdash .x,d : \tau}[name]
~

### Accesses

~ Math
\infer{
  \Pi,\Gamma,\Delta \vdash e_1 : \tau_1,d [ ] \\
  \Pi,\Gamma,\Delta \vdash e_2 : \tau_2,\_ \\
  numeric(\tau_2)
}{\Pi,\Gamma,\Delta \vdash e_1[e_2] : \tau_1,d }[array \; access]
~

~ Math
\infer{
  \Pi,\Gamma,\Delta \vdash e_1 : bit<a>,d \\
  \Pi,\Gamma,\Delta \vdash e_2  : \tau_2,\_ \\
  numeric(\tau_2) \\
  e_2 \rightsquigarrow_\tau a_2 \\
  \Pi,\Gamma,\Delta \vdash e_3  : \tau_3,\_ \\
  numeric(\tau_3) \\
  e_3 \rightsquigarrow_\tau a_3 \\
  0 \leq a_2  \leq a_3 < a \\
}{\Pi,\Gamma,\Delta \vdash e_1[e_2:e_3] : bit<a_3 - a_2 + 1> }[bit \; string \; access]
~

~ Math
\infer{
  \forall i \in [1,n], \,
  \Pi,\Gamma,\Delta \vdash e_i : \tau_i, \_
}{
  \Pi,\Gamma,\Delta \vdash \{e_1,...,e_n\} :
  \{\tau_1,...,\tau_n\}, none
}[list]
~

### Unary Operations

~ Math
\infer{
  \Pi,\Gamma,\Delta \vdash e : bool,d
}{
  \Pi,\Gamma,\Delta \vdash !e : bool,d
}[not]
~

<!--
not sure how to format tilde
-->

~ Math
\infer{
  \Pi,\Gamma,\Delta \vdash e : bit<a>,d
}{
  \Pi,\Gamma,\Delta \vdash \tilde e : bit<a>,d
}[bit \; not]
~

~ Math
\infer{
  \Pi,\Gamma,\Delta \vdash e : \tau,d \\
  numeric(\tau)
}{
  \Pi,\Gamma,\Delta \vdash -e : \tau,d
}[unary \; minus]
~

### Binary Operations

```haskell
  fun binaryDir In In = In
    | binaryDir _  _  = none
```

~ Math
\infer{
  \Pi,\Gamma,\Delta \vdash e_1 : bool,d_1 \\
  \Pi,\Gamma,\Delta \vdash e_2 : bool,d_2 \\
  d = binaryDir(d_1,d_2) \\
  \diamond \in \{ \& \&,|| \}
}{
  \Pi,\Gamma,\Delta \vdash e_1 \diamond e_2 : bool,d
}[and, \, or]
~

~ Math
\infer{
  \Pi,\Gamma,\Delta \vdash e_1 : int,d_1 \\
  \Pi,\Gamma,\Delta \vdash e_2 : int,d_2 \\
  d = binaryDir(d_1,d_2) \\
  \diamond \in \{ +,-,*,<,>,\leq,\geq, /, \% \}
}{
  \Pi,\Gamma,\Delta \vdash e_1 \diamond e_2 : int,d
}[binary \, int \, operations]
~

~ Math
\infer{
  \Pi,\Gamma,\Delta \vdash e_1 : int<a>,d_1 \\
  \Pi,\Gamma,\Delta \vdash e_2 : int<a>,d_2 \\
  d = binaryDir(d_1,d_2) \\
  \diamond \in \{ +,-,*,<,>,\leq,\geq,|+|,|-| \}
}{
  \Pi,\Gamma,\Delta \vdash e_1 \diamond e_2 : int<a>,d
}[binary \, fixed \, width \, int \, operations]
~

<!--
having trouble with ^ symbol for xor
-->

~ Math
\infer{
  \Pi,\Gamma,\Delta \vdash e_1 : bit<a>,d_1 \\
  \Pi,\Gamma,\Delta \vdash e_2 : bit<a>,d_2 \\
  d = binaryDir(d_1,d_2) \\
  \diamond \in \{ +,-,*,<,>,\leq,\geq,|+|,|-|,\&,|,\oplus \}
}{
  \Pi,\Gamma,\Delta \vdash e_1 \diamond e_2 : bit<a>,d
}[bit \, string \, binary \, operations]
~

<!--
need to define has_equality
-->

~ Math
\infer{
  \Pi,\Gamma,\Delta \vdash e_1 : \tau_1,d_1 \\
  \Pi,\Gamma,\Delta \vdash e_2 : \tau_2,d_2 \\
  \tau_1 = \tau_2 \\
  d = binaryDir(d_1,d_2) \\
  has\_equality(\tau_1)
  \diamond \in \{ ==,!= \}
}{
  \Pi,\Gamma,\Delta \vdash e_1 \diamond e_2 : bool,d
}[equality]
~

~ Math
\infer{
  \Pi,\Gamma,\Delta \vdash e_1 : bit<a_1>,d_1 \\
  \Pi,\Gamma,\Delta \vdash e_2 : bit<a_2>,d_2 \\
  d = binaryDir(d_1,d_2) \\
}{
  \Pi,\Gamma,\Delta \vdash e_1 ++ e_2 : bit<a_1+a_2>,d
}[concatenation]
~

~ Math
\infer{
  \Pi,\Gamma,\Delta \vdash e_1 : \tau_1,d_1 \\
  \Pi,\Gamma,\Delta \vdash e_2 : \tau_2,d_2 \\
  numeric(\tau_1) \\
  \tau_2 = bit<\_> \lor \tau_2 = int<\_> \\
  d = binaryDir(d_1,d_2) \\
  \diamond \in \{<<,>>\}
}{
  \Pi,\Gamma,\Delta \vdash e_1 \diamond e_2 : \tau_1,d
}[shift]
~

### Casts

<!--
need to legal casts
-->

~ Math
\infer{
  \Pi,\Gamma,\Delta \vdash e : \tau',d \\
  legal\_cast(\tau',\tau)
}{
  \Pi,\Gamma,\Delta \vdash (\tau) e : \tau,d
}[casts]
~

### Member expressions

~ Math
\infer{
  \Delta(X) = enum \, X: \tau \, \{m_1,...,m_n \} \\
  m_i = name
}{
  \Pi,\Gamma,\Delta \vdash X.name : \tau ,none
}[error \, member]
~

~ Math
\infer{
  ERROR.name \in dom(\Pi)
}{
  \Pi,\Gamma,\Delta \vdash ERROR.name : Error,none
}[error \, member]
~

~ Math
\infer{
  \Pi,\Gamma,\Delta \vdash e : H[n] \{f_1 : \tau_1, ... , f_n : \tau_n\}, \_ \\
  f_i = name
}{
  \Pi,\Gamma,\Delta \vdash e.name : \tau_i,none
}[header \, member]
~

~ Math
\infer{
  \Pi,\Gamma,\Delta \vdash e : HU \{f_1 : \tau_1, ... , f_n : \tau_n\}, \_ \\
  f_i = name
}{
  \Pi,\Gamma,\Delta \vdash e.name : \tau_i,none
}[header \, union \, member]
~

~ Math
\infer{
  \Pi,\Gamma,\Delta \vdash e : struct \, X \{f_1 : \tau_1, ... , f_n : \tau_n\}, \_ \\
  f_i = name
}{
  \Pi,\Gamma,\Delta \vdash e.name : \tau_i,none
}[struct \, member]
~

~ Math
\infer{
  \Pi,\Gamma,\Delta \vdash e : extern \, X \{...,m_i<X_1,...,X_n>(x_1:\tau_1,...,x_n:\tau_n) : \tau,...\}, \_ \\
  m_i = name
}{
  \Pi,\Gamma,\Delta \vdash e.name : m_i<X_1,...,X_n>(x_1:\tau_1,...,x_n:\tau_n), none
}[extern \, member]
~

### Ternary Expression

~ Math
\infer{
  \Pi,\Gamma,\Delta \vdash e_1 : bool, \_ \\
  \Pi,\Gamma,\Delta \vdash e_2 : \tau, \_ \\
  \Pi,\Gamma,\Delta \vdash e_3 : \tau, \_ \\
}{
  \Pi,\Gamma,\Delta \vdash e_1 ? e_2 : e_3 : \tau,none
}[ternary]
~

<!--
~ Math
\infer{}{}[function \, calls: \, named \, arguments]
~
-->

# Dynamic Semantics { #sec-dynamic }
